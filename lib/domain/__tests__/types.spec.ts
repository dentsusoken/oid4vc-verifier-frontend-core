import { describe, expect, it } from 'vitest';
import { Jwt } from '../types';

describe('types', () => {
  describe('Jwt type', () => {
    it('should accept valid JWT string values', () => {
      const validJwts: Jwt[] = [
        'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c',
        'eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9.eyJhdWQiOiJjbGllbnQtaWQiLCJpc3MiOiJodHRwczovL2V4YW1wbGUuY29tIiwiaWF0IjoxNjcwMTIzNDU2fQ.signature',
        'header.payload.signature',
        'a.b.c',
        '',
      ];

      for (const jwt of validJwts) {
        // Type assignment should work without errors
        const jwtValue: Jwt = jwt;
        expect(jwtValue).toBe(jwt);
        expect(typeof jwtValue).toBe('string');
      }
    });

    it('should work in function parameters', () => {
      function processJwt(token: Jwt): string {
        return `Processing JWT: ${token.length} characters`;
      }

      const testJwt: Jwt =
        'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIn0.signature';
      const result = processJwt(testJwt);

      expect(result).toContain('Processing JWT:');
      expect(result).toContain('characters');
    });

    it('should work in object properties', () => {
      interface TokenResponse {
        accessToken: Jwt;
        refreshToken: Jwt;
        expiresIn: number;
      }

      const tokenResponse: TokenResponse = {
        accessToken: 'eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJ1c2VyMTIzIn0.signature',
        refreshToken:
          'eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJ1c2VyMTIzIiwidHlwZSI6InJlZnJlc2gifQ.signature',
        expiresIn: 3600,
      };

      expect(typeof tokenResponse.accessToken).toBe('string');
      expect(typeof tokenResponse.refreshToken).toBe('string');
      expect(tokenResponse.expiresIn).toBe(3600);
    });

    it('should work with arrays', () => {
      const jwtArray: Jwt[] = [
        'jwt1.payload.signature1',
        'jwt2.payload.signature2',
        'jwt3.payload.signature3',
      ];

      expect(jwtArray).toHaveLength(3);
      for (const jwt of jwtArray) {
        expect(typeof jwt).toBe('string');
        expect(jwt).toContain('.');
      }
    });

    it('should support string methods', () => {
      const jwt: Jwt = 'eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJ1c2VyIn0.signature';

      // String methods should be available
      expect(jwt.length).toBeGreaterThan(0);
      expect(jwt.includes('.')).toBe(true);
      expect(jwt.split('.')).toHaveLength(3);
      expect(jwt.startsWith('eyJ')).toBe(true);
      expect(jwt.endsWith('signature')).toBe(true);
    });

    it('should work with template literals', () => {
      const issuer = 'https://example.com';
      const subject = 'user123';

      // This would typically be generated by a JWT library
      const jwt: Jwt = `header.${btoa(
        JSON.stringify({ iss: issuer, sub: subject })
      )}.signature`;

      expect(jwt).toContain('header.');
      expect(jwt).toContain('.signature');
      expect(typeof jwt).toBe('string');
    });

    it('should work with conditional types', () => {
      function isValidJwt(token: string): token is Jwt {
        // Simple JWT format validation (3 parts separated by dots)
        return token.split('.').length === 3;
      }

      const validToken = 'header.payload.signature';
      const invalidToken = 'not.a.jwt.token.with.too.many.parts';

      if (isValidJwt(validToken)) {
        // Within this block, validToken is typed as Jwt
        const jwt: Jwt = validToken;
        expect(jwt).toBe(validToken);
      }

      expect(isValidJwt(validToken)).toBe(true);
      expect(isValidJwt(invalidToken)).toBe(false);
    });

    it('should handle edge cases', () => {
      const edgeCases: Jwt[] = [
        '', // empty string
        '.', // single dot
        '..', // double dot
        'a..c', // empty middle part
        'very-long-jwt-token-that-might-exceed-normal-length-limits-but-should-still-be-valid-as-a-string-type',
        'jwt-with-special-characters!@#$%^&*()',
        'jwt\nwith\nnewlines',
        'jwt\twith\ttabs',
        'jwt with spaces',
        'jwt-with-unicode-🔐-characters',
      ];

      for (const jwt of edgeCases) {
        // Should compile and run without errors
        const jwtValue: Jwt = jwt;
        expect(jwtValue).toBe(jwt);
        expect(typeof jwtValue).toBe('string');
      }
    });

    it('should work with JSON serialization', () => {
      interface ApiResponse {
        success: boolean;
        token: Jwt;
        message: string;
      }

      const response: ApiResponse = {
        success: true,
        token: 'eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJ1c2VyIn0.signature',
        message: 'Authentication successful',
      };

      const serialized = JSON.stringify(response);
      const parsed = JSON.parse(serialized) as ApiResponse;

      expect(parsed.token).toBe(response.token);
      expect(typeof parsed.token).toBe('string');
    });

    it('should maintain type safety with union types', () => {
      type TokenOrError = Jwt | { error: string };

      function getToken(valid: boolean): TokenOrError {
        if (valid) {
          return 'eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJ1c2VyIn0.signature';
        }
        return { error: 'Invalid credentials' };
      }

      const validResult = getToken(true);
      const invalidResult = getToken(false);

      if (typeof validResult === 'string') {
        // Type narrowed to Jwt
        const jwt: Jwt = validResult;
        expect(jwt).toContain('.');
      } else {
        // Type narrowed to error object
        expect(validResult.error).toBeDefined();
      }

      expect(typeof validResult).toBe('string');
      expect(typeof invalidResult).toBe('object');
    });

    it('should work with optional properties', () => {
      interface AuthContext {
        userId: string;
        accessToken?: Jwt;
        refreshToken?: Jwt;
      }

      const contextWithTokens: AuthContext = {
        userId: 'user123',
        accessToken: 'access.token.signature',
        refreshToken: 'refresh.token.signature',
      };

      const contextWithoutTokens: AuthContext = {
        userId: 'user456',
      };

      expect(contextWithTokens.accessToken).toBeDefined();
      expect(contextWithTokens.refreshToken).toBeDefined();
      expect(contextWithoutTokens.accessToken).toBeUndefined();
      expect(contextWithoutTokens.refreshToken).toBeUndefined();
    });
  });
});
